@page "/"
@using System.Net.Http
@using System.Text.Json
@using System.Text.RegularExpressions
@inject IJSRuntime JSRuntime
@inject HttpClient Http

<div class="analyzer-page">
    <div class="container analyzer-container">
        <div class="analyzer-header">
            <div class="header-title">
                <h3>Анализатор кода проекта (CI/CD стиль)</h3>
            </div>
            <button class="clear-history-btn" @onclick="ClearAnalysisHistory" title="Очистить историю">
                <i class="bi bi-trash"></i>
            </button>
        </div>
        <div class="input-form">
            <label>Путь к папке (или ссылка на проект):</label>
            <input @bind="folderPath" placeholder="Введите путь к папке..." />
            <label>Промпт для анализа (оставьте пустым для CI/CD режима):</label>
            <textarea @bind="prompt" placeholder="Введите кастомный промпт или оставьте пустым для автоматических проверок..." rows="4"></textarea>
            <label>Расширения файлов (через запятую):</label>
            <input @bind="extensionsInput" placeholder=".cs,.js,.py,.txt,.md" />
        </div>

        <!-- Статус анализа -->
        <div class="analysis-status">
            @if (isAnalyzing)
            {
                <div class="status-info">
                    <div class="spinner"></div>
                    <span>Анализ выполняется...</span>
                </div>
            }
        </div>

        <ul class="analysis-history">
            @foreach (var message in analysisHistory)
            {
                <li class="@(message.Type == MessageType.User ? "user-message" : "bot-message")">
                    @if (message.Type == MessageType.User)
                    {
                        <div class="message-header">
                            <strong>Запрос:</strong>
                        </div>
                        <div class="message-content">
                            @foreach (var line in message.Text.Split('\n'))
                            {
                                <p>@line</p>
                            }
                        </div>
                    }
                    else
                    {
                        <div class="message-content formatted-content">
                            @if (!string.IsNullOrEmpty(message.Text))
                            {
                                @((MarkupString)FormatMarkdown(message.Text))
                            }
                        </div>
                    }
                    @if (!string.IsNullOrEmpty(message.Timestamp))
                    {
                        <div class="message-timestamp">
                            <small>@message.Timestamp</small>
                        </div>
                    }
                </li>
            }
        </ul>
        <div class="input-container">
            <button @onclick="StartAnalysis" disabled="@(isAnalyzing)">
                @if (isAnalyzing)
                {
                    <span>Анализируется...</span>
                }
                else
                {
                    <span>Анализировать</span>
                }
            </button>
        </div>
    </div>
</div>

@code {
    private List<AnalysisMessage> analysisHistory = new List<AnalysisMessage>();
    private string folderPath = string.Empty;
    private string prompt = string.Empty;
    private string extensionsInput = ".cs,.js,.py,.txt,.md";
    private bool isAnalyzing = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadAnalysisHistory();
    }

    private async Task LoadAnalysisHistory()
    {
        try
        {
            var historyJson = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "AnalysisHistory");
            if (!string.IsNullOrEmpty(historyJson))
            {
                analysisHistory = JsonSerializer.Deserialize<List<AnalysisMessage>>(historyJson);
            }
            else
            {
                analysisHistory.Add(new AnalysisMessage
                    {
                        Text = "Введите путь к папке проекта, опциональный промпт (оставьте пустым для CI/CD проверок) и расширения для анализа.",
                        Type = MessageType.Bot
                    });
                await SaveAnalysisHistory();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Ошибка при загрузке истории анализа: " + ex.Message);
            analysisHistory.Add(new AnalysisMessage
                {
                    Text = "Ошибка при загрузке истории: " + ex.Message,
                    Type = MessageType.Bot
                });
            await SaveAnalysisHistory();
        }
    }

    private async Task SaveAnalysisHistory()
    {
        try
        {
            var historyJson = JsonSerializer.Serialize(analysisHistory);
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "AnalysisHistory", historyJson);
        }
        catch (Exception ex)
        {
            Console.WriteLine("Ошибка при сохранении истории анализа: " + ex.Message);
        }
    }

    private async Task ClearAnalysisHistory()
    {
        analysisHistory.Clear();
        analysisHistory.Add(new AnalysisMessage
            {
                Text = "Введите путь к папке проекта, опциональный промпт (оставьте пустым для CI/CD проверок) и расширения для анализа.",
                Type = MessageType.Bot
            });
        await SaveAnalysisHistory();
        StateHasChanged();
    }

    private async Task StartAnalysis()
    {
        if (string.IsNullOrWhiteSpace(folderPath))
            return;

        isAnalyzing = true;

        analysisHistory.Add(new AnalysisMessage
            {
                Text = $"Папка: {folderPath}\nПромпт: {(string.IsNullOrWhiteSpace(prompt) ? "CI/CD режим" : prompt)}\nРасширения: {extensionsInput}",
                Type = MessageType.User,
                Timestamp = DateTime.Now.ToString("HH:mm:ss")
            });

        var extensions = extensionsInput.Split(',').Select(e => e.Trim()).ToList();
        await SaveAnalysisHistory();
        StateHasChanged();

        try
        {
            var request = new
            {
                FolderPath = folderPath,
                Prompt = prompt,
                Extensions = extensions
            };

            var response = await Http.PostAsJsonAsync("https://localhost:7131/api/codeanalyzer/analyze", request);

            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<AnalysisResponse>();
                if (result != null && result.Success)
                {
                    analysisHistory.Add(new AnalysisMessage
                        {
                            Text = result.Result ?? "Анализ завершен без результата",
                            Type = MessageType.Bot,
                            Timestamp = DateTime.Now.ToString("HH:mm:ss")
                        });
                }
                else
                {
                    analysisHistory.Add(new AnalysisMessage
                        {
                            Text = "Ошибка: Не удалось получить результат анализа",
                            Type = MessageType.Bot
                        });
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                analysisHistory.Add(new AnalysisMessage
                    {
                        Text = $"Ошибка сервера: {response.StatusCode} - {errorContent}",
                        Type = MessageType.Bot
                    });
            }
        }
        catch (HttpRequestException ex)
        {
            analysisHistory.Add(new AnalysisMessage
                {
                    Text = $"Ошибка сети: {ex.Message}",
                    Type = MessageType.Bot
                });
        }
        catch (Exception ex)
        {
            analysisHistory.Add(new AnalysisMessage
                {
                    Text = $"Ошибка: {ex.Message}",
                    Type = MessageType.Bot
                });
        }
        finally
        {
            isAnalyzing = false;
            await SaveAnalysisHistory();
            StateHasChanged();
        }
    }

    private string FormatMarkdown(string markdownText)
    {
        if (string.IsNullOrEmpty(markdownText))
            return string.Empty;

        // Обработка заголовков
        var formatted = Regex.Replace(markdownText, @"^###\s+(.+)$", "<h3>$1</h3>", RegexOptions.Multiline);
        formatted = Regex.Replace(formatted, @"^##\s+(.+)$", "<h2>$1</h2>", RegexOptions.Multiline);
        formatted = Regex.Replace(formatted, @"^#\s+(.+)$", "<h1>$1</h1>", RegexOptions.Multiline);

        // Обработка жирного текста
        formatted = Regex.Replace(formatted, @"\*\*(.*?)\*\*", "<strong>$1</strong>");
        formatted = Regex.Replace(formatted, @"__(.*?)__", "<strong>$1</strong>");

        // Обработка курсива
        formatted = Regex.Replace(formatted, @"\*(.*?)\*", "<em>$1</em>");
        formatted = Regex.Replace(formatted, @"_(.*?)_", "<em>$1</em>");

        // Обработка списков
        formatted = Regex.Replace(formatted, @"^\-\s+(.+)$", "<li>$1</li>", RegexOptions.Multiline);
        formatted = Regex.Replace(formatted, @"^\*\s+(.+)$", "<li>$1</li>", RegexOptions.Multiline);

        // Группировка элементов списка в ul
        formatted = Regex.Replace(formatted, @"(<li>.*</li>\s*)+", "<ul>$0</ul>");

        // Обработка нумерованных списков
        formatted = Regex.Replace(formatted, @"^\d+\.\s+(.+)$", "<li>$1</li>", RegexOptions.Multiline);
        formatted = Regex.Replace(formatted, @"(<li>.*</li>\s*)+", match =>
        {
            var items = match.Value;
            if (Regex.IsMatch(items, @"^\d+\."))
                return "<ol>" + items + "</ol>";
            else
                return "<ul>" + items + "</ul>";
        });

        // Обработка блоков кода
        formatted = Regex.Replace(formatted, @"```(\w+)?\s*(.*?)```", "<pre><code>$2</code></pre>", RegexOptions.Singleline);
        formatted = Regex.Replace(formatted, @"`(.+?)`", "<code>$1</code>");

        // Обработка разделителей
        formatted = Regex.Replace(formatted, @"^\s*---\s*$", "<hr />", RegexOptions.Multiline);

        // Обработка ссылок
        formatted = Regex.Replace(formatted, @"\[([^\]]+)\]\(([^)]+)\)", "<a href=\"$2\">$1</a>");

        // Обработка переносов строк (замена на <br>)
        formatted = Regex.Replace(formatted, @"\n", "<br />");

        // Обработка эмодзи и специальных символов
        formatted = Regex.Replace(formatted, @"📊", "<span class=\"emoji\">📊</span>");
        formatted = Regex.Replace(formatted, @"🛠️", "<span class=\"emoji\">🛠️</span>");
        formatted = Regex.Replace(formatted, @"🔹", "<span class=\"emoji\">🔹</span>");
        formatted = Regex.Replace(formatted, @"🎯", "<span class=\"emoji\">🎯</span>");
        formatted = Regex.Replace(formatted, @"📄", "<span class=\"emoji\">📄</span>");
        formatted = Regex.Replace(formatted, @"📋", "<span class=\"emoji\">📋</span>");
        formatted = Regex.Replace(formatted, @"📈", "<span class=\"emoji\">📈</span>");
        formatted = Regex.Replace(formatted, @"🔍", "<span class=\"emoji\">🔍</span>");
        formatted = Regex.Replace(formatted, @"🧠", "<span class=\"emoji\">🧠</span>");
        formatted = Regex.Replace(formatted, @"🔄", "<span class=\"emoji\">🔄</span>");
        formatted = Regex.Replace(formatted, @"❌", "<span class=\"emoji error\">❌</span>");
        formatted = Regex.Replace(formatted, @"✅", "<span class=\"emoji success\">✅</span>");

        return formatted;
    }

    public class AnalysisMessage
    {
        public string Text { get; set; } = string.Empty;
        public MessageType Type { get; set; }
        public string Timestamp { get; set; } = string.Empty;
    }

    public class AnalysisResponse
    {
        public bool Success { get; set; }
        public string Result { get; set; } = string.Empty;
        public string Error { get; set; } = string.Empty;
    }

    public enum MessageType
    {
        User,
        Bot
    }
}

<style>
    /* Стили остаются без изменений, но добавим для Pass/Fail */
    .formatted-content strong {
        color: #2c3e50;
    }

    .emoji.success {
        color: #27ae60;
    }

    .emoji.error {
        color: #e74c3c;
    }
</style>